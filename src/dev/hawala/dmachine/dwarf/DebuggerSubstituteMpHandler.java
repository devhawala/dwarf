/*
Copyright (c) 2017, Dr. Hans-Walter Latz
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * The name of the author may not be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package dev.hawala.dmachine.dwarf;

import java.util.ArrayList;
import java.util.List;

import dev.hawala.dmachine.engine.Cpu;
import dev.hawala.dmachine.engine.Cpu.MPHandler;
import dev.hawala.dmachine.engine.Cpu.MesaERROR;

/**
 * Maintenance Code handler looking for a crash of the mesa OS signaled
 * by the debugger substitute build in BWS. The idea is to interpret
 * the MP codes issued by the debugger substitute until the MP codes
 * begin to loop, stopping the mesa engine with a message built from
 * the MP codes, (very) roughly indicating the reason for the crash.
 * <br>
 * (see the <i>6085 field training</i> document for details on the MP
 * codes generated by the debugger substitute)
 * <p>
 * Furthermore, the MP code 0915 is intercepted by default and halts
 * the mesa engine, as no networking is currently available, so no
 * remote debugger can connect to this machine (if an XDE with a debugger
 * should ever be available...).
 * </p>
 * 
 * @author Dr. Hans-Walter Latz / Berlin (2017)
 */
public class DebuggerSubstituteMpHandler implements MPHandler  {
	
	// intercept MP code 0915 (waiting for remote debugger to connect)? 
	private final boolean stopOn0915;
	
	/**
	 * Constructor with parametrization for MP 915.
	 *  
	 * @param stopOn0915 should a MP 0915 stop the mesa engine?
	 */
	public DebuggerSubstituteMpHandler(boolean stopOn0915) {
		this.stopOn0915 = stopOn0915;
	}
	
	/**
	 * Default constructor, activating MP 0915 interception.
	 */
	public DebuggerSubstituteMpHandler() {
		this(true);
	}
	
	// did we see the characteristic debugger substitue MP code?
	private boolean inDebuggerSubstitute = false;
	
	// the list of the substitutes MP codes seen so far
	private List<Integer> codes = new ArrayList<>();
	
	// did we have the MP code for the crash location and reason?
	private boolean hadLocationAndKind = false;
	
	// StringBuilder to collect the characters encoded in the MP codes
	private StringBuilder sb = new StringBuilder();
	
	// the letters indexed by the MP code nibbles
	private final char[] letters = {
			' ',
			'A', 'B', 'C', 'D', 'E', 'F',
			'G', 'H', 'I', 'J', 'K', 'L',
			'M', 'N', 'O', 'P', 'Q', 'R',
			'S', 'T', 'U', 'V', 'W', 'X',
			'Y', 'Z'
	};
	
	// safe get the character for an MP code nibble
	private char letter(int l) {
		if (l >= 0 && l <= 26) {
			return this.letters[l];
		}
		return '?';
	}
	
	@Override
	public void newMP(int mp) {
		// special case "wait for remote debugger to connect"
		if (mp == 915) {
			if (this.stopOn0915) {
				throw new Cpu.MesaStopped("Start waiting for remote debugger to connect (MP 0915)");
			}
			return;
		}
		
		// handle debugger substitute MP sequences indicating where the crash occured
		
		if (mp == 8888 && this.inDebuggerSubstitute) {
			// the debugger substitute seems to interspread dummy 8888 codes between real codes
			// => ignore them
			return;
		}
		
		if (mp == 9999 && this.inDebuggerSubstitute) {
			// beginning new mp code loop => the sequence is complete, so finalize the crash reason message and stop
			sb.append(" [");
			for (Integer c : codes) {
				sb.append(String.format(" %04d", c.intValue()));
			}
			sb.append(" ]");
			throw new MesaERROR(sb.toString());
		}
		
		if (mp == 9999 && !this.inDebuggerSubstitute) {
			// start of debugger substitute mp code sequence
			codes.add(mp);
			sb.append("DbgSubst :: ");
			this.inDebuggerSubstitute = true;
			return;
		}
		
		if (this.inDebuggerSubstitute) {
			codes.add(mp);
			if (!this.hadLocationAndKind) {
				int location = mp / 100;
				int kind = mp % 100;
				
				switch(location) {
				case 76: sb.append("BWS boot, "); break;
				case 77: sb.append("BWS common software, "); break;
				case 78: sb.append("BWS applications, "); break;
				default: sb.append("?unknown(").append(location).append(")?, ");
				}
				
				switch(kind) {
				case 40: sb.append("address fault : "); break;
				case 41: sb.append("breakpoint : "); break;
				case 42: sb.append("bug : "); break;
				case 43: sb.append("call debugger : "); break;
				case 44: sb.append("map log : "); break;
				case 45: sb.append("disk error : "); break;
				case 46: sb.append("interrupt : "); break;
				case 47: sb.append("return : "); break;
				case 48: sb.append("return aborted : "); break;
				case 49: sb.append("uncaught signal : "); break;
				case 50: sb.append("visit debugger : "); break;
				case 51: sb.append("write protect : "); break;
				default: sb.append("?unknown(").append(location).append(")? : ");
				}
				
				this.hadLocationAndKind = true;
			} else {
				// here we have  more letters for the message
				int l1 = mp / 100;
				int l2 = mp % 100;
				sb.append(this.letter(l1));
				sb.append(this.letter(l2));
			}
		}
	}
}